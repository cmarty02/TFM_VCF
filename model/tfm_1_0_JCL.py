# -*- coding: utf-8 -*-
"""TFM_1.0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zq_JwMVo03tIr7disuRoUZdzne2RK8wW

IMPORTACIONES
"""

!pip install pandas openpyxl tensorflow keras
#Conexión a Colab
from google.colab import drive
drive.mount('/content/drive')

"""LECTURA DEL EXCEL Y PRE-PROCESADO"""

import pandas as pd
from sklearn.preprocessing import LabelEncoder, MinMaxScaler

# Cargar datos desde el archivo Excel
df_football = pd.read_excel('/content/drive/MyDrive/PYTHON/TFM/MODELOS/00_Previo/TFM_VCF_train_01.xlsx')

# Convertir las fechas a números ordinales
df_football['Fecha'] = pd.to_datetime(df_football['Fecha']).map(pd.Timestamp.toordinal)

# Reemplazar "-" con NaN y convertir a float
numeric_columns = ['C/VM', 'Elo (EO)', 'Elo (CO)', 'Partidos', 'Goles', 'Asistencias', 'Goles Concedidos', 'RDT']
for column in numeric_columns:
    df_football[column] = pd.to_numeric(df_football[column].replace("-", "0"))

# Asegurarse de que las columnas numéricas tengan el tipo de dato correcto
df_football[numeric_columns] = df_football[numeric_columns].astype(float)

# Normalizar características numéricas
scaler = MinMaxScaler()
df_football[numeric_columns] = scaler.fit_transform(df_football[numeric_columns])

# Comprobar que todo está OK
df_football.info()

"""MODELADO"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
import tensorflow as tf
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Embedding, Flatten, Concatenate, Dense, Dropout, BatchNormalization
from tensorflow.keras.callbacks import EarlyStopping

# Codificar los campos categóricos
le_team_origin = LabelEncoder()
le_team_dest = LabelEncoder()
le_league_origin = LabelEncoder()
le_league_dest = LabelEncoder()
le_position = LabelEncoder()

df_football['Equipo origen'] = le_team_origin.fit_transform(df_football['Equipo origen'])
df_football['Equipo destino'] = le_team_dest.fit_transform(df_football['Equipo destino'])
df_football['Competición origen'] = le_league_origin.fit_transform(df_football['Competición origen'])
df_football['Competición destino'] = le_league_dest.fit_transform(df_football['Competición destino'])
df_football['Posición'] = le_position.fit_transform(df_football['Posición'])

# Preparar los datos para el modelo
X = {
    'Equipo_origen': df_football['Equipo origen'].values,
    'Equipo_destino': df_football['Equipo destino'].values,
    'Competición_origen': df_football['Competición origen'].values,
    'Competición_destino': df_football['Competición destino'].values,
    'Posición': df_football['Posición'].values,
    'Edad': df_football['Edad'].values,
    'Fecha': df_football['Fecha'].values,
    'VM (TM)': df_football['VM (TM)'].values,
    'C/VM': df_football['C/VM'].values,
    'Elo (EO)': df_football['Elo (EO)'].values,
    'Elo (ED)': df_football['Elo (ED)'].values,
    'Elo (CO)': df_football['Elo (CO)'].values,
    'Elo (CD)': df_football['Elo (CD)'].values,
    'Partidos': df_football['Partidos'].values,
    'Goles': df_football['Goles'].values,
    'Asistencias': df_football['Asistencias'].values,
    'Goles Concedidos': df_football['Goles Concedidos'].values,
    'RDT': df_football['RDT'].values
}
y = df_football['Coste'].values

# Verificar la consistencia de las longitudes
for key in X:
    print(f'{key} length: {len(X[key])}')
print(f'Coste length: {len(y)}')

# Asegurarse de que todas las entradas sean arrays de numpy y convertir a float si es necesario
for key in X:
    if key != 'Posición':  # 'Posición' debe seguir siendo un entero para las embeddings
        X[key] = np.array(X[key]).astype(float)
    else:
        X[key] = np.array(X[key])
    print(f'{key} type: {type(X[key])}, dtype: {X[key].dtype}')  # Verificar el tipo de dato y el tipo de datos de cada entrada en X

# Verificar la longitud de cada variable individualmente
for key in X:
    if len(X[key]) != len(y):
        print(f"Inconsistencia encontrada en la variable: {key}")

# Dividir cada entrada individualmente
X_train_dict = {}
X_test_dict = {}

for key in X:
    X_train_dict[key], X_test_dict[key] = train_test_split(X[key], test_size=0.2, random_state=42)

# Dividir el objetivo
y_train, y_test = train_test_split(y, test_size=0.2, random_state=42)

# Definir las dimensiones de las embeddings
embedding_dim = 10

# Definir las entradas
input_team_origin = Input(shape=(1,), name='Equipo_origen')
input_team_dest = Input(shape=(1,), name='Equipo_destino')
input_league_origin = Input(shape=(1,), name='Competición_origen')
input_league_dest = Input(shape=(1,), name='Competición_destino')
input_position = Input(shape=(1,), name='Posición')

# Definir las capas de embeddings
team_origin_embedding = Embedding(input_dim=len(le_team_origin.classes_), output_dim=embedding_dim)(input_team_origin)
team_dest_embedding = Embedding(input_dim=len(le_team_dest.classes_), output_dim=embedding_dim)(input_team_dest)
league_origin_embedding = Embedding(input_dim=len(le_league_origin.classes_), output_dim=embedding_dim)(input_league_origin)
league_dest_embedding = Embedding(input_dim=len(le_league_dest.classes_), output_dim=embedding_dim)(input_league_dest)
position_embedding = Embedding(input_dim=len(le_position.classes_), output_dim=embedding_dim)(input_position)

# Aplanar las capas de embeddings
team_origin_flat = Flatten()(team_origin_embedding)
team_dest_flat = Flatten()(team_dest_embedding)
league_origin_flat = Flatten()(league_origin_embedding)
league_dest_flat = Flatten()(league_dest_embedding)
position_flat = Flatten()(position_embedding)

# Otras características numéricas
input_edad = Input(shape=(1,), name='Edad')
input_fecha = Input(shape=(1,), name='Fecha')
input_vm = Input(shape=(1,), name='VM (TM)')
input_cvm = Input(shape=(1,), name='C_VM')
input_elo_eo = Input(shape=(1,), name='Elo (EO)')
input_elo_ed = Input(shape=(1,), name='Elo (ED)')
input_elo_co = Input(shape=(1,), name='Elo (CO)')
input_elo_cd = Input(shape=(1,), name='Elo (CD)')
input_partidos = Input(shape=(1,), name='Partidos')
input_goles = Input(shape=(1,), name='Goles')
input_asistencias = Input(shape=(1,), name='Asistencias')
input_goles_concedidos = Input(shape=(1,), name='Goles Concedidos')
input_rdt = Input(shape=(1,), name='RDT')

# Concatenar todas las entradas
concatenated = Concatenate()([
    team_origin_flat, team_dest_flat, league_origin_flat, league_dest_flat, position_flat,
    input_edad, input_fecha, input_vm, input_cvm, input_elo_eo, input_elo_ed,
    input_elo_co, input_elo_cd, input_partidos, input_goles, input_asistencias,
    input_goles_concedidos, input_rdt
])

# Añadir capas densas con regularización y batch normalization
x = Dense(128, activation='relu')(concatenated)
x = BatchNormalization()(x)
x = Dropout(0.5)(x)
x = Dense(64, activation='relu')(x)
x = BatchNormalization()(x)
x = Dropout(0.5)(x)
x = Dense(32, activation='relu')(x)
x = BatchNormalization()(x)
x = Dropout(0.5)(x)
output = Dense(1, name='Coste')(x)

# Definir y compilar el modelo
model = Model(inputs=[
    input_team_origin, input_team_dest, input_league_origin, input_league_dest, input_position,
    input_edad, input_fecha, input_vm, input_cvm, input_elo_eo, input_elo_ed,
    input_elo_co, input_elo_cd, input_partidos, input_goles, input_asistencias,
    input_goles_concedidos, input_rdt
], outputs=output)
optimizer = tf.keras.optimizers.Adam(learning_rate=0.001)  # Ajusta la tasa según sea necesario
model.compile(optimizer=optimizer, loss='mse')

# Entrenar el modelo
early_stopping = EarlyStopping(monitor='loss', patience=10, restore_best_weights=True)

history = model.fit(
    [
        X_train_dict['Equipo_origen'], X_train_dict['Equipo_destino'], X_train_dict['Competición_origen'], X_train_dict['Competición_destino'], X_train_dict['Posición'],
        X_train_dict['Edad'], X_train_dict['Fecha'], X_train_dict['VM (TM)'], X_train_dict['C/VM'], X_train_dict['Elo (EO)'], X_train_dict['Elo (ED)'],
        X_train_dict['Elo (CO)'], X_train_dict['Elo (CD)'], X_train_dict['Partidos'], X_train_dict['Goles'], X_train_dict['Asistencias'],
        X_train_dict['Goles Concedidos'], X_train_dict['RDT']
    ],
    y_train,
    epochs=50,
    batch_size=32,
    validation_data=(
        [
            X_test_dict['Equipo_origen'], X_test_dict['Equipo_destino'], X_test_dict['Competición_origen'], X_test_dict['Competición_destino'], X_test_dict['Posición'],
            X_test_dict['Edad'], X_test_dict['Fecha'], X_test_dict['VM (TM)'], X_test_dict['C/VM'], X_test_dict['Elo (EO)'], X_test_dict['Elo (ED)'],
            X_test_dict['Elo (CO)'], X_test_dict['Elo (CD)'], X_test_dict['Partidos'], X_test_dict['Goles'], X_test_dict['Asistencias'],
            X_test_dict['Goles Concedidos'], X_test_dict['RDT']
        ],
        y_test
    ),
    callbacks=[early_stopping]
)

# Evaluar el modelo
loss = model.evaluate(
    [
        X_test_dict['Equipo_origen'], X_test_dict['Equipo_destino'], X_test_dict['Competición_origen'], X_test_dict['Competición_destino'], X_test_dict['Posición'],
        X_test_dict['Edad'], X_test_dict['Fecha'], X_test_dict['VM (TM)'], X_test_dict['C/VM'], X_test_dict['Elo (EO)'], X_test_dict['Elo (ED)'],
        X_test_dict['Elo (CO)'], X_test_dict['Elo (CD)'], X_test_dict['Partidos'], X_test_dict['Goles'], X_test_dict['Asistencias'],
        X_test_dict['Goles Concedidos'], X_test_dict['RDT']
    ],
    y_test
)

print(f'Mean Squared Error en el conjunto de prueba: {loss}')

"""RANDOM FOREST"""

import pandas as pd
import numpy as np
import joblib
from sklearn.preprocessing import LabelEncoder, MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error

# Codificar los campos categóricos
le_team_origin = LabelEncoder()
le_team_dest = LabelEncoder()
le_league_origin = LabelEncoder()
le_league_dest = LabelEncoder()
le_position = LabelEncoder()

df_football['Equipo origen'] = le_team_origin.fit_transform(df_football['Equipo origen'])
df_football['Equipo destino'] = le_team_dest.fit_transform(df_football['Equipo destino'])
df_football['Competición origen'] = le_league_origin.fit_transform(df_football['Competición origen'])
df_football['Competición destino'] = le_league_dest.fit_transform(df_football['Competición destino'])
df_football['Posición'] = le_position.fit_transform(df_football['Posición'])

# Preparar los datos para el modelo
X = df_football.drop(columns=['Jugador', 'Temporada', 'Coste'])
y = df_football['Coste']

# Dividir en conjunto de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Crear y entrenar el modelo de Random Forest
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)

# Hacer predicciones y evaluar el modelo
y_pred = rf_model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
print(f'Mean Squared Error en el conjunto de prueba: {mse}')

joblib.dump(rf_model, '/content/drive/MyDrive/PYTHON/TFM/MODELOS/Modelos_entrenados/random_forest_model_01.pkl')

"""PRUEBA MODELO RANDOM FOREST VS ARCHIVO TEST"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder, MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import joblib

# Cargar el nuevo archivo de datos
df_test = pd.read_excel('/content/drive/MyDrive/PYTHON/TFM/MODELOS/00_Previo/TFM_VCF_test_01.xlsx')

# Convertir las fechas a números ordinales
df_test['Fecha'] = pd.to_datetime(df_test['Fecha']).map(pd.Timestamp.toordinal)

# Reemplazar "-" con NaN y convertir a float
numeric_columns = ['C/VM', 'Elo (EO)', 'Elo (CO)', 'Partidos', 'Goles', 'Asistencias', 'Goles Concedidos', 'RDT']
for column in numeric_columns:
    df_test[column] = pd.to_numeric(df_test[column].replace("-", "0"))

# Asegurarse de que las columnas numéricas tengan el tipo de dato correcto
df_test[numeric_columns] = df_test[numeric_columns].astype(float)

# Normalizar características numéricas
scaler = MinMaxScaler()
df_test[numeric_columns] = scaler.fit_transform(df_test[numeric_columns])

# Codificar los campos categóricos (usando pd.factorize para evitar problemas con categorías desconocidas)
df_test['Equipo origen'] = pd.factorize(df_test['Equipo origen'])[0]
df_test['Equipo destino'] = pd.factorize(df_test['Equipo destino'])[0]
df_test['Competición origen'] = pd.factorize(df_test['Competición origen'])[0]
df_test['Competición destino'] = pd.factorize(df_test['Competición destino'])[0]
df_test['Posición'] = pd.factorize(df_test['Posición'])[0]

# Preparar los datos para el modelo
X_new = df_test.drop(columns=['Jugador', 'Temporada', 'Coste'])
y_true = df_test['Coste']

# Cargar el modelo de Random Forest
rf_model = joblib.load('/content/drive/MyDrive/PYTHON/TFM/MODELOS/Modelos_entrenados/random_forest_model_01.pkl')

# Hacer predicciones
y_pred = rf_model.predict(X_new)

# Evaluar las predicciones
mse = mean_squared_error(y_true, y_pred)
mae = mean_absolute_error(y_true, y_pred)
r2 = r2_score(y_true, y_pred)

print(f'Mean Squared Error: {mse}')
print(f'Mean Absolute Error: {mae}')
print(f'R^2 Score: {r2}')

# Mostrar algunas predicciones junto con los valores reales
df_results = df_test[['Jugador', 'Coste']].copy()
df_results['Predicted_Coste'] = y_pred
print(df_results.head(10))

import matplotlib.pyplot as plt

# Importancia de características
feature_importances = rf_model.feature_importances_
features = X.columns
importance_df = pd.DataFrame({'Feature': features, 'Importance': feature_importances})
importance_df = importance_df.sort_values(by='Importance', ascending=False)

# Visualizar la importancia de las características
plt.figure(figsize=(10, 6))
plt.barh(importance_df['Feature'], importance_df['Importance'])
plt.xlabel('Importance')
plt.ylabel('Feature')
plt.title('Feature Importances in Random Forest Model')
plt.gca().invert_yaxis()
plt.show()

"""XG BOOST"""

import pandas as pd
from sklearn.preprocessing import LabelEncoder, MinMaxScaler

# Cargar datos desde el archivo Excel
df_football = pd.read_excel('/content/drive/MyDrive/PYTHON/TFM/MODELOS/00_Previo/TFM_VCF_train_01.xlsx')

# Convertir las fechas a números ordinales
df_football['Fecha'] = pd.to_datetime(df_football['Fecha']).map(pd.Timestamp.toordinal)

# Reemplazar "-" con NaN y convertir a float
numeric_columns = ['C/VM', 'Elo (EO)', 'Elo (CO)', 'Partidos', 'Goles', 'Asistencias', 'Goles Concedidos', 'RDT']
for column in numeric_columns:
    df_football[column] = pd.to_numeric(df_football[column].replace("-", "0"))

# Asegurarse de que las columnas numéricas tengan el tipo de dato correcto
df_football[numeric_columns] = df_football[numeric_columns].astype(float)

# Normalizar características numéricas
scaler = MinMaxScaler()
df_football[numeric_columns] = scaler.fit_transform(df_football[numeric_columns])

# Comprobar que todo está OK
df_football.info()

# Codificar los campos categóricos
le_team_origin = LabelEncoder()
le_team_dest = LabelEncoder()
le_league_origin = LabelEncoder()
le_league_dest = LabelEncoder()
le_position = LabelEncoder()

df_football['Equipo origen'] = le_team_origin.fit_transform(df_football['Equipo origen'])
df_football['Equipo destino'] = le_team_dest.fit_transform(df_football['Equipo destino'])
df_football['Competición origen'] = le_league_origin.fit_transform(df_football['Competición origen'])
df_football['Competición destino'] = le_league_dest.fit_transform(df_football['Competición destino'])
df_football['Posición'] = le_position.fit_transform(df_football['Posición'])

# Preparar los datos para el modelo
X = df_football.drop(columns=['Jugador', 'Temporada', 'Coste'])
y = df_football['Coste']

# Dividir en conjunto de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Crear y entrenar el modelo de XGBoost
xgb_model = xgb.XGBRegressor(objective='reg:squarederror', random_state=42)
xgb_model.fit(X_train, y_train)

# Hacer predicciones
y_pred = xgb_model.predict(X_test)

# Evaluar las predicciones
mse = mean_squared_error(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f'Mean Squared Error: {mse}')
print(f'Mean Absolute Error: {mae}')
print(f'R^2 Score: {r2}')

# Mostrar algunas predicciones junto con los valores reales
df_results = pd.DataFrame({'Jugador': df_football.loc[X_test.index, 'Jugador'],
                           'Coste': y_test, 'Predicted_Coste': y_pred})
print(df_results.head(10))

# Guardar el modelo entrenado
joblib.dump(xgb_model, '/content/drive/MyDrive/PYTHON/TFM/MODELOS/xgboost_model_01.pkl')

"""PRUEBA VS TEST"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder, MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import joblib

# Cargar el nuevo archivo de datos
df_test = pd.read_excel('/content/drive/MyDrive/PYTHON/TFM/MODELOS/00_Previo/TFM_VCF_test_01.xlsx')

# Convertir las fechas a números ordinales
df_test['Fecha'] = pd.to_datetime(df_test['Fecha']).map(pd.Timestamp.toordinal)

# Reemplazar "-" con NaN y convertir a float
numeric_columns = ['C/VM', 'Elo (EO)', 'Elo (CO)', 'Partidos', 'Goles', 'Asistencias', 'Goles Concedidos', 'RDT']
for column in numeric_columns:
    df_test[column] = pd.to_numeric(df_test[column].replace("-", "0"))

# Asegurarse de que las columnas numéricas tengan el tipo de dato correcto
df_test[numeric_columns] = df_test[numeric_columns].astype(float)

# Normalizar características numéricas
scaler = MinMaxScaler()
df_test[numeric_columns] = scaler.fit_transform(df_test[numeric_columns])

# Codificar los campos categóricos usando los mismos encoders entrenados
df_test['Equipo origen'] = pd.factorize(df_test['Equipo origen'])[0]
df_test['Equipo destino'] = pd.factorize(df_test['Equipo destino'])[0]
df_test['Competición origen'] = pd.factorize(df_test['Competición origen'])[0]
df_test['Competición destino'] = pd.factorize(df_test['Competición destino'])[0]
df_test['Posición'] = pd.factorize(df_test['Posición'])[0]

# Preparar los datos para el modelo
X_new = df_test.drop(columns=['Jugador', 'Temporada', 'Coste'])
y_true = df_test['Coste']

# Cargar el modelo de XGBoost
xgb_model = joblib.load('/content/drive/MyDrive/PYTHON/TFM/MODELOS/xgboost_model_01.pkl')

# Hacer predicciones
y_pred = xgb_model.predict(X_new)

# Evaluar las predicciones
mse = mean_squared_error(y_true, y_pred)
mae = mean_absolute_error(y_true, y_pred)
r2 = r2_score(y_true, y_pred)

print(f'Mean Squared Error: {mse}')
print(f'Mean Absolute Error: {mae}')
print(f'R^2 Score: {r2}')

# Mostrar algunas predicciones junto con los valores reales
df_results = pd.DataFrame({'Jugador': df_test['Jugador'],
                           'Coste': y_true, 'Predicted_Coste': y_pred})
print(df_results.head(10))

"""PRUEBAS MODELO COMBINADO"""